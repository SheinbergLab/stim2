# examples/motionpatch/mp_shape.tcl
# Shape-Defined Motion Demonstration
# Demonstrates: image masks, figure/ground segregation, two-color mode
#
# Motion dots are masked by a shape - dots inside the shape can have
# different color/luminance than dots outside, creating figure/ground
# segregation purely from motion and luminance cues.

load_Impro

# ============================================================
# STIM CODE
# ============================================================

# Render polygon to RGBA texture
proc mp_render_shape {x y size r g b} {
    set width $size
    set height $size
    set depth 4
    set half [expr {$size / 2}]
    
    # Scale normalized coords (-1 to 1) to pixel coords
    dl_local xscaled [dl_add [dl_mult $x $half] $half]
    dl_local yscaled [dl_add [dl_mult [dl_negate $y] $half] $half]
    
    # Create image and draw filled polygon
    set img [img_create -width $width -height $height -depth $depth]
    set poly [img_drawPolygon $img $xscaled $yscaled $r $g $b 255]
    
    # Convert to DYN_LIST for texture
    dl_local pix [img_img2list $poly]
    
    # Cleanup impro images
    img_delete $img $poly
    
    # Create texture (RGBA = 4 channels)
    set tex [imageTextureFromList $pix $width $height LINEAR]
    return $tex
}

# Generate circle vertices
proc mp_make_circle {npoints} {
    set step [expr {2.0 * 3.14159265 / $npoints}]
    dl_local angles [dl_fromto 0 [expr {2.0 * 3.14159265}] $step]
    dl_local x [dl_mult [dl_cos $angles] 0.7]
    dl_local y [dl_mult [dl_sin $angles] 0.7]
    return [list $x $y]
}

# Generate square vertices
proc mp_make_square {} {
    dl_local x [dl_flist -0.7 0.7 0.7 -0.7 -0.7]
    dl_local y [dl_flist -0.7 -0.7 0.7 0.7 -0.7]
    return [list $x $y]
}

# Generate arrow vertices
proc mp_make_arrow {} {
    # Arrow pointing up, normalized to fit in -1 to 1
    dl_local x [dl_flist -0.15 -0.15 -0.4 0.0 0.4 0.15 0.15 -0.15]
    dl_local y [dl_flist -0.6 0.1 0.1 0.7 0.1 0.1 -0.6 -0.6]
    return [list $x $y]
}

# Generate star vertices
proc mp_make_star {npoints} {
    set outer 0.7
    set inner 0.35
    set n [expr {$npoints * 2}]
    set step [expr {2.0 * 3.14159265 / $n}]
    dl_local angles [dl_fromto 0 [expr {2.0 * 3.14159265 - $step}] $step]
    # Alternate between outer and inner radius
    dl_local radii [dl_repeat [dl_flist $outer $inner] $npoints]
    dl_local x [dl_mult [dl_cos $angles] $radii]
    dl_local y [dl_mult [dl_sin $angles] $radii]
    return [list $x $y]
}

proc mp_shape_setup {shape lumdiff} {
    glistInit 1
    resetObjList
    shaderImageReset
    
    set pedestal 0.6
    set nDots 4000
    set texSize 256
    
    # Generate shape vertices based on selection
    switch $shape {
        circle { lassign [mp_make_circle 64] x y }
        square { lassign [mp_make_square] x y }
        arrow  { lassign [mp_make_arrow] x y }
        star   { lassign [mp_make_star 5] x y }
    }
    
    # Create mask texture from shape
    set tex [mp_render_shape $x $y $texSize 255 255 255]
    
    # Create motionpatch
    set mp [motionpatch $nDots 0.01 20]
    objName $mp dots
    
    # Set two colors based on luminance difference
    set c1 [expr {$pedestal + $lumdiff / 2.0}]
    set c2 [expr {$pedestal - $lumdiff / 2.0}]
    motionpatch_color $mp $c1 $c1 $c1 1.0
    motionpatch_color2 $mp $c2 $c2 $c2 1.0
    
    motionpatch_pointsize $mp 4.0
    motionpatch_masktype $mp 1
    motionpatch_coherence $mp 1.0
    motionpatch_direction $mp 0.0
    motionpatch_speed $mp 0.005
    
    # Apply mask texture - mode 3 = two-color (color inside, color2 outside)
    motionpatch_setSampler $mp [shaderImageID $tex] 0
    motionpatch_samplermaskmode $mp 3
    
    # Wrap in metagroup for transforms
    set mg [metagroup]
    metagroupAdd $mg $mp
    objName $mg patch
    scaleObj $mg 8.0 8.0
    
    glistAddObject $mg 0
    glistSetDynamic 0 1
    glistSetCurGroup 0
    glistSetVisible 1
    redraw
}

# ---- Adjuster helper procs ----

proc mp_shape_set_motion {name coherence direction speed} {
    motionpatch_coherence $name $coherence
    motionpatch_direction $name [expr {$direction * 3.14159265 / 180.0}]
    motionpatch_speed $name $speed
}

proc mp_shape_get_motion {name} {
    dict create coherence 1.0 direction 0 speed 0.005
}

proc mp_shape_set_pointsize {name pointsize} {
    motionpatch_pointsize $name $pointsize
}

proc mp_shape_get_pointsize {name} {
    dict create pointsize 4.0
}

# ============================================================
# WORKSPACE DEMO INTERFACE
# ============================================================
workspace::reset

workspace::setup mp_shape_setup {
    shape   {choice {circle square arrow star} circle "Shape"}
    lumdiff {float 0.0 0.5 0.05 0.2 "Luminance Difference"}
} -adjusters {shape_motion shape_pointsize shape_transform} \
  -label "Shape-Defined Motion"

workspace::adjuster shape_motion {
    coherence {float 0.0 1.0 0.05 1.0 "Coherence"}
    direction {float 0 360 15 0 "Direction (deg)"}
    speed     {float 0.0 0.01 0.0005 0.005 "Speed"}
} -target dots -proc mp_shape_set_motion -getter mp_shape_get_motion \
  -label "Motion"

workspace::adjuster shape_pointsize {
    pointsize {float 1.0 10.0 0.5 4.0 "Dot Size"}
} -target dots -proc mp_shape_set_pointsize -getter mp_shape_get_pointsize \
  -label "Dot Size"

workspace::adjuster shape_transform -template scale -target patch \
  -label "Patch Size"
